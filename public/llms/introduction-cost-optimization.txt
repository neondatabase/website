# Cost optimization

> The "Cost Optimization" document outlines strategies and configurations for Neon users to efficiently manage and reduce expenses associated with database operations.

## Source

- [Cost optimization HTML](https://neon.com/docs/introduction/cost-optimization): The original HTML version of this documentation

Managing your Neon costs effectively requires understanding how each billing factor works and implementing strategies to control usage. This guide provides actionable recommendations for optimizing costs across all billing metrics.

## ☑ Compute (CU-hours)

Compute is typically the largest component of your Neon bill. You're charged based on compute size (in CUs) multiplied by the hours your compute is running.

**Optimization strategies:**

- **Right-size your compute** — Start by determining the appropriate compute size for your workload. Your compute should be large enough to cache your frequently accessed data (your working set) in memory. A compute that's too small can lead to poor query performance, while an oversized compute wastes resources. See [How to size your compute](https://neon.com/docs/manage/computes#how-to-size-your-compute) for guidance.

- **Use autoscaling effectively** — Configure [autoscaling](https://neon.com/docs/introduction/autoscaling) to dynamically adjust compute resources based on demand. Set your minimum size to handle your baseline workload and your maximum to accommodate peak traffic. You only pay for what you use. See [Enable autoscaling](https://neon.com/docs/guides/autoscaling-guide) for configuration steps.

- **Enable scale to zero** — For non-production environments or databases with intermittent usage, enable [scale to zero](https://neon.com/docs/introduction/scale-to-zero) to suspend your compute after 5 minutes of inactivity. This can dramatically reduce compute costs for development, testing, and preview environments. See [Configuring scale to zero](https://neon.com/docs/guides/scale-to-zero-guide).

- **Manage persistent connections and scheduled jobs** — Applications that maintain long-lived connections or scheduled jobs (like cron tasks) can prevent your compute from scaling to zero, keeping it active 24/7. If these aren't critical, consider closing idle connections or adjusting job schedules to allow scale to zero during off-peak hours.

- **Be aware of logical replication impact** — If you're using [logical replication](https://neon.com/docs/guides/logical-replication-neon), note that computes with active replication subscribers will not scale to zero, resulting in 24/7 compute usage. Plan accordingly and consider whether logical replication is necessary for all environments.

## ☑ Storage (root and child branches)

Storage costs are based on actual data size for root branches and the minimum of accumulated changes or logical data size for child branches, billed in GB-months.

**Optimization strategies:**

- **Manage child branch storage** — Child branches are billed for the minimum of accumulated data changes or your logical data size—capped at your actual data size. While this prevents charges from exceeding your data size, managing branches effectively still helps minimize costs:
  - Set a [time to live](https://neon.com/docs/guides/branch-expiration) on development and preview branches
  - Delete child branches when they're no longer needed
  - For production workloads, use a [root branch](https://neon.com/docs/manage/branches#root-branch) instead—root branches are billed on your actual data size.

- **Implement branch lifecycle management** — Review your branches regularly and delete any that are no longer needed. Keeping your branch count under control reduces both storage costs and potential [extra branch charges](https://neon.com/docs/introduction/plans#extra-branches).

## ☑ Instant restore storage

Instant restore storage is based on the amount of change history (WAL records) retained, not the number of restores performed.

**Optimization strategies:**

- **Adjust your restore window** — By default, Neon retains history for 6 hours on Free plan projects and 1 day on paid plan projects. You can increase this up to the maximum for your plan (6 hours for Free, 7 days for Launch, 30 days for Scale). If you don't need much recovery capability, you can reduce your restore window to lower costs. Find the right balance between restore capability and cost. See [Configure your restore window](https://neon.com/docs/manage/projects#configure-your-restore-window).

- **Understand the trade-offs** — Reducing your restore window decreases instant restore storage costs but limits how far back you can restore data. Consider your actual recovery requirements and set the window accordingly.

## ☑ Extra branches

Extra branches beyond your plan's allowance are billed at $1.50/branch-month, prorated hourly. Plans include 10 branches for Free and Launch, 25 for Scale.

**Optimization strategies:**

- **Use branch expiration** — Set automatic deletion timestamps on temporary branches using [branch expiration](https://neon.com/docs/guides/branch-expiration) to ensure they're cleaned up when no longer needed.

- **Automate cleanup** — Consider implementing automated cleanup scripts using the [Neon API](https://neon.com/docs/manage/branches#branching-with-the-neon-api) or [Neon CLI](https://neon.com/docs/guides/branching-neon-cli) to stay within your plan's branch allowance.

## ☑ Public data transfer

Public network transfer (egress) is the data sent from your databases over the public internet. Free plans include 5 GB/month, while paid plans include 100 GB/month, then $0.10/GB.

**Optimization strategies:**

- **Monitor your data transfer** — Be aware of how much data you're transferring out of Neon. This includes:
  - Data sent to client applications
  - [Logical replication](https://neon.com/docs/reference/glossary#logical-replication) to any destination, including other Neon databases

- **Review your bill** — If you see unexpectedly high public data transfer charges, [contact support](https://neon.com/docs/introduction/support) for assistance. Neon does not currently expose detailed data transfer metrics in the Console.
