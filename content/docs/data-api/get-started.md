---
title: Getting started with Neon Data API
subtitle: Learn how to enable and use the Neon Data API
enableTableOfContents: true
updatedOn: '2025-11-30T00:00:00.000Z'
tag: beta
---

<FeatureBetaProps feature_name="Neon Data API" />

In this guide, you'll learn how to enable the Neon Data API for your database, create a table with Row-Level Security (RLS), and run your first query.

<Steps>

## Enable the Data API

<Admonition type="important" title="Data API is branch-specific">
The Neon Data API is enabled at the **branch** level for a single database. Each branch has its own Data API configuration, so you must select the appropriate branch before enabling the API.
</Admonition>

To enable the Neon Data API, navigate to the **Data API** section in the Neon Console sidebar and click **Enable**.

![Data API page with enable button](/docs/data-api/data_api_sidebar.png)

Select an authentication method:

- **Neon Auth** (recommended): Integrates with Neon Auth for seamless user and token management. Ideal for applications requiring user authentication.
- **Bring Your Own Auth**: Use your own authentication system by providing the JWKS URL for your auth provider.
- **No Auth**: No authentication integration. Suitable for server-side scripts or backends where you manage tokens manually or authentication isn't required. _(under development)_

<Admonition type="warning" title="Authentication required">
**All requests to the Data API currently require authentication** with a valid JWT token. Anonymous access is not supported yet, but is coming soon. In the near future, we'll provide public/long-lived tokens for anonymous users.
</Admonition>

![Data API enabled view](/docs/data-api/data-api-enabled.png)

<Admonition type="note">
Neon Data API is incompatible with [IP Allow](/docs/manage/projects#configure-ip-allow). Please ensure IP Allow is disabled before proceeding.
</Admonition>

Once enabled, Neon provisions:

1.  A dedicated **REST API endpoint** (e.g., `https://.../rest/v1`).
2.  **Neon Auth** integration for managing users and tokens (if selected).

## Create a table with RLS

The Data API interacts directly with your Postgres schema. Because the API is accessible over the internet, it's crucial to enforce security at the database level using PostgreSQL's **Row-Level Security (RLS)** features.

For guidance on writing RLS policies, see our [PostgreSQL RLS tutorial](/postgresql/postgresql-administration/postgresql-row-level-security) for the basics, or our recommended [Drizzle RLS guide](/docs/guides/rls-drizzle) for a simpler approach.

In this example, we'll create a `posts` table where users can read published posts and manage their own posts securely. Run the following SQL in the [Neon SQL Editor](/docs/get-started-with-neon/query-with-neon-sql-editor) to create a `posts` table with RLS policies:

<CodeTabs labels={["SQL", "Drizzle (crudPolicy)", "Drizzle (pgPolicy)"]}>

```sql
-- 1. Create the table
CREATE TABLE posts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id text DEFAULT (auth.user_id()) NOT NULL,
  content text NOT NULL,
  is_published boolean DEFAULT false,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL
);

-- 2. Enable RLS
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- 3. Create Policy: Users can see all published posts and their own posts
CREATE POLICY "Public read access" ON posts
  AS PERMISSIVE
  FOR SELECT TO authenticated
  USING (is_published OR (select auth.user_id() = "posts"."user_id"));

-- 4. Create Policy: Users can insert their own posts
CREATE POLICY "Users can insert their own posts" ON posts
  AS PERMISSIVE
  FOR INSERT TO "authenticated"
  WITH CHECK ((select auth.user_id() = "posts"."user_id"));

-- 5. Create Policy: Users can update their own posts
CREATE POLICY "Users can update their own posts" ON posts
  AS PERMISSIVE
  FOR UPDATE TO "authenticated"
  USING ((select auth.user_id() = "posts"."user_id"))
  WITH CHECK ((select auth.user_id() = "posts"."user_id"));

CREATE POLICY "Users can delete their own posts" ON posts
  AS PERMISSIVE
  FOR DELETE TO "authenticated"
  USING ((select auth.user_id() = "posts"."user_id"));
```

```typescript
import { sql } from 'drizzle-orm';
import { crudPolicy, authenticatedRole, authUid } from 'drizzle-orm/neon';
import { bigint, boolean, pgTable, text, timestamp } from 'drizzle-orm/pg-core';

export const posts = pgTable(
  'posts',
  {
    id: bigint({ mode: 'number' }).primaryKey(),
    userId: text('user_id')
      .notNull()
      .default(sql`(auth.user_id())`),
    content: text().notNull(),
    isPublished: boolean('is_published').notNull().default(false),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [
    // Policy for authenticated users
    crudPolicy({
      role: authenticatedRole,
      read: sql`is_published OR (select auth.user_id() = ${table.userId})`, // Can read published posts or their own posts
      modify: authUid(table.userId), // Can only modify their own posts
    }),
  ]
);
```

```typescript
import { sql } from 'drizzle-orm';
import { authenticatedRole, authUid } from 'drizzle-orm/neon';
import { bigint, boolean, pgPolicy, pgTable, text, timestamp } from 'drizzle-orm/pg-core';

export const posts = pgTable(
  'posts',
  {
    id: bigint({ mode: 'number' }).primaryKey(),
    userId: text('user_id')
      .notNull()
      .default(sql`(auth.user_id())`),
    content: text().notNull(),
    isPublished: boolean('is_published').notNull().default(false),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [
    // Authenticated users
    pgPolicy('Allow authenticated users to read published posts and their own posts', {
      to: authenticatedRole,
      for: 'select',
      using: sql`is_published OR (select auth.user_id() = ${table.userId})`,
    }),
    pgPolicy('Allow authenticated users to insert their own posts', {
      to: authenticatedRole,
      for: 'insert',
      withCheck: authUid(table.userId),
    }),
    pgPolicy('Allow authenticated users to update their own posts', {
      to: authenticatedRole,
      for: 'update',
      using: authUid(table.userId),
      withCheck: authUid(table.userId),
    }),
    pgPolicy('Allow authenticated users to delete their own posts', {
      to: authenticatedRole,
      for: 'delete',
      using: authUid(table.userId),
    }),
  ]
);
```

</CodeTabs>

<Admonition type="info" title="What is auth.user_id() and authUid()?">
`auth.user_id()` is a Data API helper that extracts the User ID from the JWT token for secure database permission enforcement. `authUid()` is a Drizzle ORM helper that simplifies using `auth.user_id()` in policies.
</Admonition>

## Refresh schema cache

When you modify your database schema (adding tables, columns, or changing structure), the Data API needs to refresh its cache.

After making any schema changes, go to the **Data API** section in the Console and click **Refresh schema cache**; the API will now reflect your latest schema.

![Data API refresh schema cache button](/docs/changelog/data_api_schema_refresh.png)

## Connect and Query

Dependending on your preference, you can connect to the Neon Data API using either the Neon SDKs or direct HTTP requests.

### Option 1: Using Neon SDK's

Install the client library and run your first query. Choose the option that fits your use case:

<Tabs labels={["With Neon Auth", "With Your Own Auth"]}>

<TabItem>

Use [`@neondatabase/neon-js`](https://www.npmjs.com/package/@neondatabase/neon-js) when connecting from a frontend or application using Neon Auth for user management.

**1. Install**

```bash
npm install @neondatabase/neon-js
```

**2. Usage**

```typescript shouldWrap
import { createClient } from '@neondatabase/neon-js';

// Initialize with Auth integration
const client = createClient({
  auth: {
    url: process.env.NEON_AUTH_URL, // e.g. https://.../neondb/auth: Your Neon Auth endpoint from the Console
  },
  dataApi: {
    url: process.env.NEON_DATA_API_URL, // e.g. https://.../rest/v1: Your Neon Data API endpoint from the Console
  },
});

// Query (Token is automatically injected if user is logged in. Refer `client.auth.signIn` methods in Neon Auth docs for login flows)
const { data, error } = await client
  .from('posts')
  .select('*')
  .eq('is_published', true)
  .order('created_at', { ascending: false });

console.log(data);
```

</TabItem>

<TabItem>

Use [`@neondatabase/postgrest-js`](https://www.npmjs.com/package/@neondatabase/postgrest-js) when using your own authentication system (like [Auth0](https://auth0.com/), [Clerk](https://clerk.com/), [Firebase Auth](https://firebase.google.com/products/auth), etc.) to provide JWT tokens for the Data API.

**1. Install**

```bash
npm install @neondatabase/postgrest-js
```

**2. Usage**

You need to provide a function that retrieves the JWT token from your authentication system. This token will be included in each request to the Data API to enforce RLS policies.

```typescript shouldWrap
import { fetchWithToken, NeonPostgrestClient } from '@neondatabase/postgrest-js';

const getTokenFromAuthSystem = async (): Promise<string> => {
  // Implement jwt token retrieval logic from your auth system using sessions, cookies, env vars, etc.
  return 'your-jwt-token';
};

// Initialize the lightweight client
const client = new NeonPostgrestClient({
  dataApiUrl: process.env.NEON_DATA_API_URL!, // e.g. https://.../rest/v1: Your Neon Data API endpoint from the Console
  options: {
    global: {
      fetch: fetchWithToken(getTokenFromAuthSystem),
    },
  },
});

// Query
const { data, error } = await client
  .from('posts')
  .select('*')
  .eq('is_published', true)
  .order('created_at', { ascending: false });

console.log(data);
```

</TabItem>

</Tabs>

> For detailed guidance on performing `INSERT`, `UPDATE`, `DELETE`, and advanced queries (filters, joins, stored procedures, etc.) in either case, refer to the [Neon Javascript SDK documentation](/docs/reference/javascript-sdk#insert).

### Option 2: Direct HTTP Requests

You can also interact with the Neon Data API directly using standard HTTP requests. Ensure you include the `Authorization` header with a valid JWT token for authentication. The JWT token must include the `sub` claim for RLS policies to work correctly.

```bash shouldWrap
curl -X GET 'https://your-neon-data-api-endpoint/rest/v1/posts?is_published=eq.true&order=created_at.desc' \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN' \
  -H 'Content-Type: application/json'
```

> For more details on constructing requests and handling responses, refer to the [PostgREST documentation](https://postgrest.org/en/stable/references/api.html).

</Steps>

## Next steps

- **RLS**: Learn more about Row-Level Security in Neon
  - [Row-Level Security with Neon](/docs/guides/row-level-security)
  - [Simplify RLS with Drizzle](/docs/guides/rls-drizzle)
- **[Generate TypeScript Types](/docs/data-api/generate-types)**: Introspect your database to get full autocomplete for your table names and columns.
